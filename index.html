<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Real World WebGL</title>
    <link rel="stylesheet" href="style.css"/>
</head>
<body>
<!-- http://planetpixelemporium.com/planets.html -->
<script type="vertex" id="vs">
        #version 300 es

        in vec4 positionLoc;
        // in vec3 colorLoc;
        in vec2 textureCoordLoc;

        out vec2 vTextureCoord;

        uniform mat4 mvpMatrix;

        void main() {
            vTextureCoord = textureCoordLoc;
            gl_Position = mvpMatrix * positionLoc ;
        }












</script>

<script type="fragment" id="fs">
        #version 300 es
        precision highp float;

        in vec2 vTextureCoord;

        out vec4 fragColor;

        uniform sampler2D uSampler;

        void main() {
            fragColor = texture(uSampler, vTextureCoord);
        }












</script>


<canvas id="webgl-canvas"></canvas>

<script type="text/javascript" src="js/Common/MV.js"></script>
<script type="text/javascript" src="js/main.js"></script>

<img id="texEarth" src="img/earthmap_squared.jpg" hidden alt="Earth Colormap"/>
<img id="bumpEarth" src="img/earthbump_squared.jpg" hidden alt="Earth Bumpmap"/>

<script>


    window.onload = () => {
        let canvas = document.getElementById("webgl-canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        let aspect = canvas.width / canvas.height;
        let eye, at, up;
        // let modelViewProjection;
        let gl = canvas.getContext("webgl2");
        if (!gl) {
            console.error("WebGL 2 not available");
            document.body.innerHTML = "This example requires WebGL 2 which is unavailable on this system."
        }
        gl.clearColor(0, 0, 0, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.enable(gl.DEPTH_TEST);

        let vsSource = document.getElementById("vs").text.trim();
        let fsSource = document.getElementById("fs").text.trim();

        let vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vsSource);
        gl.compileShader(vertexShader);
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(vertexShader));
        }
        let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fsSource);
        gl.compileShader(fragmentShader);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(fragmentShader));
        }
        let program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);
        let image = document.getElementById("texEarth");
        texture = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.uniform1i(gl.getUniformLocation(program, "textureMap"), 0);

        // const sphereObj = sphere_way1(12);
        const {positions, textureCoords} = sphere_way2(50, 50, 1.5, [1, 1, 1, 1]);

        let positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, flatten(positions), gl.STATIC_DRAW);
        let positionLoc = gl.getAttribLocation(program, "positionLoc");
        gl.vertexAttribPointer(positionLoc, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionLoc);

        // let normalBuffer = gl.createBuffer();
        // gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
        // gl.bufferData(gl.ARRAY_BUFFER, flatten(sphereObj.normals), gl.STATIC_DRAW);
        // let normalLoc = gl.getAttribLocation(program, "normalLoc");
        // gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);
        // gl.enableVertexAttribArray(normalLoc);

        let textureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, flatten(textureCoords), gl.STATIC_DRAW);
        let textureCoordLoc = gl.getAttribLocation(program, "textureCoordLoc");
        gl.vertexAttribPointer(textureCoordLoc, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(textureCoordLoc);

        ////////////////
        // DRAW
        ////////////////
        //gl.clear(gl.COLOR_BUFFER_BIT);

        let l_modelViewProjectionMatrixLoc = gl.getUniformLocation(program, "mvpMatrix");

        let earthZ = 23.5;
        let earthX = 0;
        let earthY = (earthX + 1) % 360;

        let autoRotate = true;
        let rotateTimeout = null;

        function resetRotateTimeout() {
            autoRotate = false;
            clearTimeout(rotateTimeout);
            rotateTimeout = setTimeout(() => {
                autoRotate = true;
            }, 5000);
        }

        document.onkeydown = (e) => {
            if (e.key === "ArrowUp") {
                earthZ = (earthZ + 1) % 360;
                resetRotateTimeout()
            } else if (e.key === "ArrowDown") {
                earthZ = (earthZ - 1) % 360;
                resetRotateTimeout()
            } else if (e.key === "ArrowLeft") {
                earthY = (earthY - 1) % 360;
                resetRotateTimeout()
            } else if (e.key === "ArrowRight") {
                earthY = (earthY + 1) % 360;
                resetRotateTimeout()
            }
        }

        let rotationMult = mat4(1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1);

        let render = function () {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            eye = vec3(0, 1, 5);
            up = vec3(0, 1, 0);
            at = vec3(0, 0, 0);
            if (autoRotate) {
                earthY = (earthY + 1) % 360;
                earthZ = 23.5;
                earthX = 0;
            }

            rotationMult = mult(mult(rotateY(earthY), rotateX(earthX)), rotateZ(earthZ));

            let translatem = translate(0, 0, 0);
            let detranslatem = translate(0, 0, 0);
            let modelMatrix = mult(detranslatem, mult(rotationMult, translatem));
            let viewMatrix = lookAt(eye, at, up);
            let modelViewMatrix = mult(viewMatrix, modelMatrix);
            let projectionMatrix = perspective(45, aspect, 3, 10);
            let l_viewProjection = mult(projectionMatrix, viewMatrix);
            let l_modelViewProjection = mult(projectionMatrix, modelViewMatrix);
            gl.uniformMatrix4fv(l_modelViewProjectionMatrixLoc, false, flatten(l_modelViewProjection));
            gl.drawArrays(gl.TRIANGLES, 0, positions.length);
            gl.uniformMatrix4fv(l_modelViewProjectionMatrixLoc, false, flatten(l_viewProjection));
            gl.drawArrays(gl.TRIANGLES, positions.length, positions.length);

            requestAnimationFrame(render);
        }

        render();
    }
</script>

</body>


</html>