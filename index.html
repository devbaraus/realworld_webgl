<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Real World WebGL</title>
    <link rel="stylesheet" href="style.css"/>
</head>
<body>
<!--http://planetpixelemporium.com/planets.html-->
<script type="x-shader/x-vertex" id="vs">
        #version 300 es

        in vec3 vertexLoc;
        // in vec3 colorLoc;
        in vec2 texCoordLoc;

        out vec2 vTextureCoord;

        uniform mat4 mvpMatrix;

        void main() {
            vTextureCoord = texCoordLoc;
            gl_Position = mvpMatrix * vec4(vertexLoc,1.0) ;
        }
</script>

<script type="x-shader/x-fragment" id="fs">
        #version 300 es
        precision mediump float;

        in vec2 vTextureCoord;

        out vec4 fragColor;

        uniform sampler2D uSampler;

        void main() {
            vec4 fragmentColor = texture(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
            fragColor = fragmentColor;
        }
</script>


<canvas id="webgl-canvas"></canvas>

<script type="text/javascript" src="js/Common/MV.js"></script>
<script type="text/javascript" src="js/main.js"></script>

<img loading="eager" id="texEarth" src="img/earthmap_squared.jpg" hidden alt="Earth Colormap"/>
<img loading="eager" id="bumpEarth" src="img/earthbump_squared.jpg" hidden alt="Earth Bumpmap"/>

<script>

    let canvas = document.getElementById("webgl-canvas");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    let aspect = canvas.width / canvas.height;
    let eye, at, up;
    // let modelViewProjection;
    let gl = canvas.getContext("webgl2");
    if (!gl) {
        console.error("WebGL 2 not available");
        document.body.innerHTML = "This example requires WebGL 2 which is unavailable on this system."
    }
    gl.clearColor(0, 0, 0, 1);
    //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.enable(gl.DEPTH_TEST);

    let vsSource = document.getElementById("vs").text.trim();
    let fsSource = document.getElementById("fs").text.trim();
    let vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vsSource);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(vertexShader));
    }
    let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fsSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(fragmentShader));
    }
    let program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
    }

    gl.useProgram(program);
    let image = document.getElementById("texEarth");
    texture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.uniform1i(gl.getUniformLocation(program, "textureMap"), 0);

    // const sphereObj = sphere_way1(12);
    const sphereObj = sphere_way2(30, 30, 1, [1, 1, 1, 1]);


    // let positionsArray = sphereObj.positions;
    // let colorsArray = [];
    // let texCoordArray = sphereObj.uvs;

    // const textureCoord = [
    //     vec2(0, 0),
    //     vec2(0, 1),
    //     vec2(1, 1),
    //     vec2(1, 0),
    // ]
    //
    //
    // for (let t in sphereObj.triangles) {
    //     // texCoordArray.push(textureCoord[0]);
    //     // texCoordArray.push(textureCoord[1]);
    //     // texCoordArray.push(textureCoord[2]);
    //     // texCoordArray.push(textureCoord[0]);
    //     // texCoordArray.push(textureCoord[1]);
    //     // texCoordArray.push(textureCoord[3]);
    //
    //
    //     colorsArray.push(vec3(1.0, 0.0, 0.0));
    //     colorsArray.push(vec3(0.0, 1.0, 0.0));
    //     colorsArray.push(vec3(0.0, 0.0, 1.0));
    // }

    // GEOGEBRA - 3D
    // for(let p of sphereObj.points){
    //     console.log(p)
    //     p[0] = p[0].toFixed(5);
    //     p[1] = p[1].toFixed(5);
    //     p[2] = p[2].toFixed(5);
    //     console.log('(' + p[0] + ', ' + p[1] + ', ' + p[2] + ')');
    // }


    let vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereObj.vertices), gl.STATIC_DRAW);
    vertexBuffer.numItems = sphereObj.vertices.length / 3;
    vertexBuffer.itemSize = 3;	// x,y,z
    let vertexLoc = gl.getAttribLocation(program, "vertexLoc");
    gl.vertexAttribPointer(vertexLoc, vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(vertexLoc);

    let normalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereObj.normals), gl.STATIC_DRAW);
    normalBuffer.numItems = sphereObj.normals.length / 3;
    normalBuffer.itemSize = 3;	// x,y,z
    let normalLoc = gl.getAttribLocation(program, "normalLoc");
    gl.vertexAttribPointer(normalLoc, normalBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(normalLoc);

    let textureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereObj.texCoords), gl.STATIC_DRAW);
    textureCoordBuffer.numItems = sphereObj.texCoords.length / 2;
    textureCoordBuffer.itemSize = 2;	// u,v
    let textureCoordLoc = gl.getAttribLocation(program, "textureCoordLoc");
    gl.vertexAttribPointer(textureCoordLoc, textureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(textureCoordLoc);

    // let indexBuffer = gl.createBuffer();
    // indexBuffer.itemSize = 1;
    // indexBuffer.numItems = sphereObj.indexes.length;
    // gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    // gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphereObj.indexes), gl.STATIC_DRAW);
    // gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    // gl.drawElements(gl.TRIANGLES, indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);


    // let colorBuffer = gl.createBuffer();
    // gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereObj.colors), gl.DYNAMIC_DRAW);
    // colorBuffer.itemSize = 4; // r,g,b,a
    // colorBuffer.numItems = sphereObj.colors.length / 4;
    // gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    // gl.vertexAttribPointer(program.vertexColorAttribute, colorBuffer.itemSize, gl.FLOAT, false, 0,0);

    ////////////////
    // DRAW
    ////////////////
    //gl.clear(gl.COLOR_BUFFER_BIT);

    let modelViewProjectionMatrixLoc = gl.getUniformLocation(program, "mvpMatrix");
    let i = 0;

    let render = function () {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        eye = vec3(0, 0.5, 2);
        up = vec3(0, 1, 0);
        at = vec3(0, 0, 0);
        i = (i) % 360;
        let translatem = translate(0, 0, -1);
        let detranslatem = translate(0, 0, 1);
        let worldmatrix = mult(detranslatem, mult(rotateY(i), translatem));
        let modelViewMatrix = mult(lookAt(eye, at, up), worldmatrix);
        let projectionMatrix = perspective(90, aspect, 0.5, 7.5);
        let modelViewProjection = mult(projectionMatrix, modelViewMatrix);
        gl.uniformMatrix4fv(modelViewProjectionMatrixLoc, false, flatten(modelViewProjection));
        gl.drawArrays(gl.TRIANGLES, 0, sphereObj.indexes.length / 3);
        requestAnimationFrame(render);
    }

    render();

</script>

</body>


</html>